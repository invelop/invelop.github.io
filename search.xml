<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux 64位环境GCC编译生成32位程序报错fatal error: bits/libc-header-start.h</title>
    <url>/2022/01/26/64%E4%BD%8D%E7%8E%AF%E5%A2%83GCC%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%9032%E4%BD%8D%E7%A8%8B%E5%BA%8F%E6%8A%A5%E9%94%99fatal-error-bits-libc-header-start-h/</url>
    <content><![CDATA[<h1 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h1><p>使用了<code>-m32</code>指令，而64位系统GCC默认安装环境无法直接编译生成32位程序</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>安装Multilib，顾名思义，就是多重的。用它可以替代原来单一的lib，这样就既能产生32位的代码，又能生成64位的代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install gcc-multilib</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>[linux ubuntu gcc编译 fatal error: bits/libc-header-start.h 错误解决]: <a href="https://blog.csdn.net/whatday/article/details/99161919">https://blog.csdn.net/whatday/article/details/99161919</a></li>
<li>[In file included from /usr/include/stdio.h:27:0, from btest.c:16: /usr/include/feat出错的解决办法]: <a href="https://blog.csdn.net/shendezhuti/article/details/96477288">https://blog.csdn.net/shendezhuti/article/details/96477288</a></li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>报错</tag>
        <tag>gcc</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中用预处理指令“注释掉”代码</title>
    <url>/2022/03/13/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%94%A8%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%E2%80%9C%E6%B3%A8%E9%87%8A%E6%8E%89%E2%80%9D%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在C语言中，为什么要用预处理指令而不是直接用注释来去除代码？</p>
<p>考虑代码中可能原先就存在注释的情况，直接在首尾加上<code>/*</code>和<code>*/</code>就可能存在前后注释符号匹配错误问题。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    statements</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这样，即使原先存在注释，也能有效”注释掉“该段代码了。</p>
<blockquote>
<p>Note: 在<code>#if</code>和<code>#endif</code>指令之间的代码，只有当<code>#if</code>后的条件成立时才会被编译</p>
</blockquote>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>注释</tag>
        <tag>预处理指令</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中字符串常量的本质</title>
    <url>/2022/03/15/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<p>在C语言中，字符串常量的直接值，实际上是一个指针，而不是这些字符本身。</p>
<p>可以这么理解，C语言中的字符串是一串以<code>&#39;\0&#39;</code>结尾的字符组成的数组。而数组和指针某种意义上是等价的。</p>
<p>也就是说，字符串常量<code>&quot;abcd&quot;</code>在表达式中实际上代表的值是该字符串第一个字符的地址。这同时也解释了为什么字符串常量可以直接赋给指针，而不能赋给数组。</p>
<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 这里通过人为的错误类型赋值，得到警告信息 */</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对&quot;abcd&quot;与指针类型进行对比操作 */</span></span><br><span class="line">    <span class="keyword">char</span> *ptr = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr: %x\n&quot;</span>, ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\&quot;abcd\&quot;: %x\n&quot;</span>, <span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr+1: %x\n&quot;</span>, ptr + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\&quot;abcd\&quot;+1: %x\n&quot;</span>, <span class="string">&quot;abcd&quot;</span> + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*\&quot;abcd\&quot;=%x\n&quot;</span>, *<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*(\&quot;abcd\&quot;+1)=%x\n&quot;</span>, *(<span class="string">&quot;abcd&quot;</span>+<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="string">&quot;abcd&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr==\&quot;abcd\&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的警告信息说明，字符串常量实际是<code>char *</code>类型：</p>
<p><img data-src="/2022/03/15/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20220315111407309.png" alt="warning"></p>
<p>输出结果如下：</p>
<p><img data-src="/2022/03/15/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20220315110648352.png" alt="result"></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux python安装包警告未安装到PATH路径</title>
    <url>/2022/01/28/Linux-python%E5%AE%89%E8%A3%85%E5%8C%85%E8%AD%A6%E5%91%8A%E6%9C%AA%E5%AE%89%E8%A3%85%E5%88%B0PATH%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>用pip安装包时警告：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">WARNING: The script script_name <span class="keyword">is</span> installed <span class="keyword">in</span> <span class="string">&#x27;/home/user_name/.local/bin&#x27;</span> which <span class="keyword">is</span> <span class="keyword">not</span> on PATH.</span><br><span class="line"> Consider adding this directory to PATH <span class="keyword">or</span>, <span class="keyword">if</span> you prefer to suppress this warning, use --no-warn-script-location.</span><br></pre></td></tr></table></figure>

<p>意思是你安装的路径<code>&#39;/home/user_name/.local/bin&#39;</code>不是PATH路径</p>
<p>这样的话你就不能在命令行里直接使用库相关的命令</p>
<p>例如我刚安装了pwntools库，如果我安装在PATH路径下，我就可以直接在命令行输入<code>pwn</code>来执行相关命令，而不是通过<code>python -m pwn</code>的方式执行相关命令</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>给出两个消除警告的方法，请根据需要选择</p>
<h2 id="法一：添加库到PATH路径"><a href="#法一：添加库到PATH路径" class="headerlink" title="法一：添加库到PATH路径"></a>法一：添加库到PATH路径</h2><p>这样配置的作用在于你可以把安装的库作为独立的命令执行，而不是通过<code>python -m</code>的方式</p>
<p>使用以下命令在<code>~/.bashrc</code>文件后追加<code>export PATH=&quot;$PATH:$HOME/.local/bin&quot;</code>这一行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;export PATH=&quot;$PATH:$HOME/.local/bin&quot;&#x27; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>然后用以下命令使刚才的配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="法二：忽略警告"><a href="#法二：忽略警告" class="headerlink" title="法二：忽略警告"></a>法二：忽略警告</h2><p>按照提示，如果您希望禁止显示此警告，请使用 <code>--no-warn-script-location</code></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>windows右键新建菜单增加md文件</title>
    <url>/2021/12/07/Windows%E5%8F%B3%E9%94%AE%E6%96%B0%E5%BB%BAmarkdown%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>因为平时经常用markdown文件，所以想到在windows中如果能直接右键新键会方便很多，查了一些资料之后，得到如下方法</p>
</blockquote>
<p>Windows右键新建菜单添加新的文件类型的方法是修改注册表，本文以添加markdown文件为例，其他文件类型同理。</p>
<p>本文提供两种方式：<strong>脚本修改</strong>和<strong>手动修改</strong>。嫌麻烦不想看那么多的可以直接用注册表脚本的方式。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>一个Markdown编辑器（本文用的是 Typora，其他的同理，如果用脚本需要相应作出更改）</li>
</ul>
<span id="more"></span>

<h2 id="修改注册表"><a href="#修改注册表" class="headerlink" title="修改注册表"></a>修改注册表</h2><h3 id="手动修改"><a href="#手动修改" class="headerlink" title="手动修改"></a>手动修改</h3><h4 id="Step-1-打开注册表编辑器"><a href="#Step-1-打开注册表编辑器" class="headerlink" title="Step-1 打开注册表编辑器"></a>Step-1 打开注册表编辑器</h4><p><code>Win + R</code>快捷键唤出运行对话框，并输入<code>regedit</code>，确定，打开注册表编辑器</p>
<p><img data-src="/2021/12/07/Windows%E5%8F%B3%E9%94%AE%E6%96%B0%E5%BB%BAmarkdown%E6%96%87%E4%BB%B6/image-20211207193130622.png" alt="运行对话框"></p>
<h4 id="Step-2-修改注册表"><a href="#Step-2-修改注册表" class="headerlink" title="Step-2 修改注册表"></a>Step-2 修改注册表</h4><ol>
<li>定位到<code>HKEY_CLASSES_ROOT\.md</code></li>
</ol>
<p><img data-src="/2021/12/07/Windows%E5%8F%B3%E9%94%AE%E6%96%B0%E5%BB%BAmarkdown%E6%96%87%E4%BB%B6/image-20211207193525490.png" alt="定位到`HKEY_CLASSES_ROOT\.md`"></p>
<ol start="2">
<li>点击<code>.md</code>文件夹, 双击右侧<code>(默认)</code>项编辑字符串，将<code>数值数据</code>改为<code>Typora.exe</code>（其他编辑器同理）</li>
</ol>
<p><img data-src="/2021/12/07/Windows%E5%8F%B3%E9%94%AE%E6%96%B0%E5%BB%BAmarkdown%E6%96%87%E4%BB%B6/image-20211207194022215.png" alt="修改数值数据"></p>
<ol start="3">
<li>右键<code>.md</code>文件夹 -&gt; 新建 -&gt; 项<code>ShellNew</code>，然后在<code>ShellNew</code>右键新建 -&gt; 字符串值<code>NullFile</code></li>
</ol>
<p><img data-src="/2021/12/07/Windows%E5%8F%B3%E9%94%AE%E6%96%B0%E5%BB%BAmarkdown%E6%96%87%E4%BB%B6/image-20211207193601993.png" alt="新建`ShellNew\NullFile`"></p>
<h3 id="脚本修改"><a href="#脚本修改" class="headerlink" title="脚本修改"></a>脚本修改</h3><p>脚本和手动修改采用的流程相同，只不过把它写成了脚本形式。新建<code>新建md文件.reg</code>文件写入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line">[HKEY_CLASSES_ROOT\.md]</span><br><span class="line">@=&quot;Typora.exe&quot;</span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line">&quot;NullFile&quot;=&quot;&quot;</span><br><span class="line">[HKEY_CLASSES_ROOT\Typora.exe]</span><br><span class="line">@=&quot;Markdown&quot;</span><br></pre></td></tr></table></figure>

<p>双击以管理员权限运行。</p>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img data-src="/2021/12/07/Windows%E5%8F%B3%E9%94%AE%E6%96%B0%E5%BB%BAmarkdown%E6%96%87%E4%BB%B6/2021-12-07.png" alt="效果图"></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Python月相设计思路</title>
    <url>/2021/12/14/Python%E6%9C%88%E7%9B%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<p>要求可以展示任一月份月相，并单击日期实现绘图。本文浅析一下该题设计思路。</p>
<p>本题关键：</p>
<ol>
<li>月历中每日对应星期</li>
<li>月相与日期对应关系</li>
<li>turtle绘制月相</li>
</ol>
<span id="more"></span>

<h2 id="月历每日对应星期"><a href="#月历每日对应星期" class="headerlink" title="月历每日对应星期"></a>月历每日对应星期</h2><p>日历相关问题可以直接用 calendar 标准库</p>
<p>月历里面有对应实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> calendar</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>year = <span class="number">2021</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>month = <span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calendar.monthcalendar(year, month)</span><br><span class="line">[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>], [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>], [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>], [<span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br></pre></td></tr></table></figure>

<p>看到该函数返回一个二维数组，表示月历中每一行（每一周）对应的日期，没有则为 0</p>
<p>应用到本题，只需要读取用户选择的年月，然后得到该函数对应的数据，用循环显示出控件即可</p>
<h2 id="月相与日期对应关系"><a href="#月相与日期对应关系" class="headerlink" title="月相与日期对应关系"></a>月相与日期对应关系</h2><p>做了点研究，月相与农历大致能一一对应，可以从这里切入。</p>
<p><img data-src="/2021/12/14/Python%E6%9C%88%E7%9B%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/8cfb7e8a8902ceecf9ad1eaca5eb0631.jpeg" alt="农历月相对照图"></p>
<p>所以本题就可以转化为农历和公历的对应关系。</p>
<p>然而，农历和公历的关系是没有规律的，农历都是天文观测的结果，因此这里只需要下载农历公历对应关系的数据即可。</p>
<p>这里网上其实有很多实现，可以直接借鉴。</p>
<p>另外，这里推荐几个可用的库：sxtwl、zhdate</p>
<h3 id="sxtwl库使用"><a href="#sxtwl库使用" class="headerlink" title="sxtwl库使用"></a>sxtwl库使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sxtwl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 阳历（公历）日期 获取一天的日期对象</span></span><br><span class="line">day = sxtwl.fromSolar(<span class="number">2021</span>, <span class="number">12</span>, <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取对应的农历信息</span></span><br><span class="line">lunar_year = day.getLunarYear()</span><br><span class="line">lunar_month = day.getLunarMonth()</span><br><span class="line">lunar_day = day.getLunarDay()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否是闰月</span></span><br><span class="line">is_lunar_leap = day.isLunarLeap()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取农历月的天数</span></span><br><span class="line">day_cnt = sxtwl.getLunarMonthNum(lunar_year, lunar_month, is_lunar_leap)</span><br></pre></td></tr></table></figure>

<p>详情请参考<a href="https://pypi.org/project/sxtwl/">https://pypi.org/project/sxtwl/</a></p>
<h2 id="turtle绘制月相"><a href="#turtle绘制月相" class="headerlink" title="turtle绘制月相"></a>turtle绘制月相</h2><p>思路是根据当前农历日与对应的农历月的总天数之比绘制月相。</p>
<p>月相可以通过类比球体投影的方式绘制。</p>
<p>把月亮想象成一个球体，则月相的变化可以看作是与其旋转轴与球面相交的两点所在的弧在旋转形成的一个投影。</p>
<p>绘制该图的关键在于绘制将月相分为明暗两面的弧。</p>
<p>想象球体的一个鸟瞰图，一半是明面，一半是暗面，明暗交界的线按农历作周期性旋转，然后月相展示的是一个正面的一个投影。</p>
<p>（此处应有图片配合，但是可惜没有…）</p>
<p>这里之前计算明暗交界线的代码有个错误，感谢qq1337361309纠正，我顺便把填充亮面的代码补全了，大家可以直接套用相关代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># orgin 为圆心坐标，此处假设为原点(0,0)，请根据实际修改</span></span><br><span class="line"><span class="comment"># radius 为球体半径</span></span><br><span class="line">radius = <span class="number">100</span></span><br><span class="line"><span class="comment"># step 为绘制弧的精度，建议画圆的时候也用类似的逻辑，这样整体样式统一一点</span></span><br><span class="line">step = <span class="number">1</span></span><br><span class="line"><span class="comment"># lunar_day 为农历日</span></span><br><span class="line">lunar_day = <span class="number">3</span></span><br><span class="line"><span class="comment"># day_cnt 为农历当月的天数</span></span><br><span class="line">day_cnt = <span class="number">29</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算偏转角</span></span><br><span class="line"><span class="comment"># fix: 农历初一偏转角应该为 0, 感谢qq1337361309纠正</span></span><br><span class="line">angle = angle = (lunar_day - <span class="number">1</span>) / day_cnt * <span class="number">360</span></span><br><span class="line"><span class="comment"># 是否从右边填充，此处填充为填充亮面</span></span><br><span class="line">fromRight = angle &gt;= <span class="number">180</span></span><br><span class="line">degree = angle % <span class="number">180</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充</span></span><br><span class="line">turtle.penup()</span><br><span class="line">turtle.goto(<span class="number">0</span>, radius)</span><br><span class="line">turtle.fillcolor(<span class="string">&quot;yellow&quot;</span>)</span><br><span class="line">turtle.begin_fill()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 描边</span></span><br><span class="line"><span class="keyword">if</span> fromRight:</span><br><span class="line">    signal = <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    signal = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(radius, -(radius+step), -step):</span><br><span class="line">    x = signal*(radius**<span class="number">2</span> - y**<span class="number">2</span>)**<span class="number">0.5</span></span><br><span class="line">    turtle.goto(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画弧</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(-radius, radius+step, step):</span><br><span class="line">    x = -(radius**<span class="number">2</span> - y**<span class="number">2</span>)**<span class="number">0.5</span> * math.cos(math.radians(degree))</span><br><span class="line">    turtle.goto(x, y)</span><br><span class="line"></span><br><span class="line">turtle.end_fill()</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;Press Enter to continue...&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img data-src="/2021/12/14/Python%E6%9C%88%E7%9B%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/image-20211215170856110.png" alt="demo"></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>课程设计</tag>
        <tag>tkinter</tag>
        <tag>turtle</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows注册右键打开菜单（上下文菜单）</title>
    <url>/2021/12/23/Windows%E6%B3%A8%E5%86%8C%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E8%8F%9C%E5%8D%95/</url>
    <content><![CDATA[<h1 id="添加菜单项"><a href="#添加菜单项" class="headerlink" title="添加菜单项"></a>添加菜单项</h1><p><code>Win+R</code>唤出运行对话框输入<code>regedit</code>打开注册表编辑器，进入目录<code>HKEY_CLASSES_ROOT\Directory\Background\shell</code>新建项，起个自己和注册的菜单有关的有意义的名字（当然你也可以随便起一个）。这里示例起的名字是<code>example</code>：</p>
<p><img data-src="/2021/12/23/Windows%E6%B3%A8%E5%86%8C%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E8%8F%9C%E5%8D%95/image-20211224173816393.png" alt="创建项example"></p>
<span id="more"></span>

<p>点击进入刚创建的项<code>example</code>，双击默认值：</p>
<p><img data-src="/2021/12/23/Windows%E6%B3%A8%E5%86%8C%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E8%8F%9C%E5%8D%95/image-20211224173933587.png" alt="image-20211224173933587"></p>
<p>修改为菜单项中要显示的名字：</p>
<p><img data-src="/2021/12/23/Windows%E6%B3%A8%E5%86%8C%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E8%8F%9C%E5%8D%95/image-20211224174027061.png" alt="设置菜单名称"></p>
<p><img data-src="/2021/12/23/Windows%E6%B3%A8%E5%86%8C%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E8%8F%9C%E5%8D%95/image-20211224174148263.png" alt="修改后注册表"></p>
<p>然后右键唤出菜单，可以看到已经多了该项：</p>
<p><img data-src="/2021/12/23/Windows%E6%B3%A8%E5%86%8C%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E8%8F%9C%E5%8D%95/image-20211224174055568.png" alt="无图标菜单效果"></p>
<h1 id="添加命令"><a href="#添加命令" class="headerlink" title="添加命令"></a>添加命令</h1><p>在<code>example</code>下创建<code>command</code>项，修改默认值为要执行的命令，这是点击对应菜单要执行的命令：</p>
<p><img data-src="/2021/12/23/Windows%E6%B3%A8%E5%86%8C%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E8%8F%9C%E5%8D%95/image-20211224174435927.png" alt="创建command项"></p>
<p>这里设置为<code>powershell echo &#39;Hello world!&#39;</code>，点击菜单会唤出<code>powershell</code>打印<code>Hello world!</code>：</p>
<p><img data-src="/2021/12/23/Windows%E6%B3%A8%E5%86%8C%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E8%8F%9C%E5%8D%95/image-20211224175349430.png" alt="设置command"></p>
<p><img data-src="/2021/12/23/Windows%E6%B3%A8%E5%86%8C%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E8%8F%9C%E5%8D%95/image-20211224180026343.png" alt="打印hello world"></p>
<h1 id="添加图标"><a href="#添加图标" class="headerlink" title="添加图标"></a>添加图标</h1><p>在<code>example</code>项下创建可扩充字符串<code>Icon</code>，设置值为<code>ico</code>文件路径或者<code>exe</code>文件路径，这里设为<code>E:\favicon.ico</code>，我在这里放了以下图标：</p>
<p><img data-src="/2021/12/23/Windows%E6%B3%A8%E5%86%8C%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E8%8F%9C%E5%8D%95/image-20211224175612961.png" alt="E:\favicon.ico"></p>
<p><img data-src="/2021/12/23/Windows%E6%B3%A8%E5%86%8C%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E8%8F%9C%E5%8D%95/image-20211224175805501.png" alt="添加图标路径"></p>
<p>效果如下：</p>
<p><img data-src="/2021/12/23/Windows%E6%B3%A8%E5%86%8C%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E8%8F%9C%E5%8D%95/image-20211224175835911.png" alt="最终效果"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p>[Windows自定义右键菜单]: <a href="https://blog.csdn.net/qq_25166683/article/details/81352868">https://blog.csdn.net/qq_25166683/article/details/81352868</a>    “详解”</p>
</li>
<li><p>[为上下文菜单编写]: <a href="https://superuser.com/questions/136838/which-special-variables-are-available-when-writing-a-shell-command-for-a-context">https://superuser.com/questions/136838/which-special-variables-are-available-when-writing-a-shell-command-for-a-context</a>    “命令拓展阅读”</p>
</li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>checksec工具安装和使用</title>
    <url>/2022/01/26/checksec%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>学Pwn的时候要用到checksec工具，用于查看程序开启了哪些保护机制</p>
<h1 id="Step1-git下载"><a href="#Step1-git下载" class="headerlink" title="Step1-git下载"></a>Step1-git下载</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/slimm609/checksec.sh.git</span><br></pre></td></tr></table></figure>



<h1 id="Step2-建立符号链接"><a href="#Step2-建立符号链接" class="headerlink" title="Step2-建立符号链接"></a>Step2-建立符号链接</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s ~/checksec.sh/checksec /usr/local/bin/checksec</span><br></pre></td></tr></table></figure>



<h1 id="Step3-使用"><a href="#Step3-使用" class="headerlink" title="Step3-使用"></a>Step3-使用</h1><p>详见<a href="https://github.com/slimm609/checksec.sh">https://github.com/slimm609/checksec.sh</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ checksec</span><br><span class="line">Usage: checksec [--format=&#123;cli,csv,xml,json&#125;] [OPTION]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line"> ## Checksec Options</span><br><span class="line">  --file=&#123;file&#125;</span><br><span class="line">  --dir=&#123;directory&#125;</span><br><span class="line">  --listfile=&#123;text file with one file per line&#125;</span><br><span class="line">  --proc=&#123;process name&#125;</span><br><span class="line">  --proc-all</span><br><span class="line">  --proc-libs=&#123;process ID&#125;</span><br><span class="line">  --kernel[=kconfig]</span><br><span class="line">  --fortify-file=&#123;executable-file&#125;</span><br><span class="line">  --fortify-proc=&#123;process ID&#125;</span><br><span class="line">  --version</span><br><span class="line">  --help</span><br><span class="line">  --update or --upgrade</span><br><span class="line"></span><br><span class="line"> ## Modifiers</span><br><span class="line">  --debug</span><br><span class="line">  --verbose</span><br><span class="line">  --format=&#123;cli,csv,xml,json&#125;</span><br><span class="line">  --output=&#123;cli,csv,xml,json&#125;</span><br><span class="line">  --extended</span><br><span class="line"></span><br><span class="line">For more information, see:</span><br><span class="line">  http://github.com/slimm609/checksec.sh</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>工具</tag>
        <tag>CTF</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo - 博客搭建全教程</title>
    <url>/2021/11/30/hello-hexo/</url>
    <content><![CDATA[<p>本文将包含本站搭建及配置全过程，长期更新。</p>
<p>本人非专业建站人员，如有错误，欢迎指正。</p>
<h1 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h1><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成<strong>静态网页</strong>。</p>
<p>这里注意，hexo是基于<strong>Node.js</strong>的一款博客框架，因此和一些<strong>PHP</strong>的博客系统是有显著区别的。</p>
<p>之前玩过 emlog, typecho, wordpress 等一些PHP的博客系统的都知道，这类博客内容是动态生成的，各种数据保存在数据库里，会有一个管理后台能直接完成交互。</p>
<p>这些hexo里面都是没有的，它完全根据你的<strong>配置文件和源文件</strong>生成对应的<strong>静态网页</strong>，就是说，你每写一篇文章，就要生成一个对应的静态网页。</p>
<p>用惯了PHP博客系统的朋友们一开始用Hexo可能不太适应，确实PHP博客系统玩起来要方便很多，但谁叫咱爱折腾呢。</p>
<h1 id="基础搭建"><a href="#基础搭建" class="headerlink" title="基础搭建"></a>基础搭建</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><a href="http://nodejs.org/">Node.js</a> - Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本</li>
<li><a href="http://git-scm.com/">Git</a></li>
</ul>
<h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><p>待完善…</p>
]]></content>
      <categories>
        <category>博客建设</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo插入本地图片</title>
    <url>/2021/12/14/hexo%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<blockquote>
<p>这篇文章随便记录一下，讲的不是很清楚，如果有需要评论区留言，我再重新写一写</p>
</blockquote>
<p>网上查的说用hexo-asset-image插件</p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>修改_config.yml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>重新生成一遍……然并卵</p>
<h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><p>好像是hexo里面参数改了</p>
<p>找到<code>node_modules/hexo-asset-image/index.js</code>，做点小改动：</p>
<span id="more"></span>

<ol>
<li>把获取img的src属性的语句改为获取data-src属性</li>
<li>修改截取绝对路径的语句</li>
</ol>
<h1 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">    <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> appendLink = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="comment">// if not with index.html endpos = link.lastIndexOf(&#x27;.&#x27;) + 1 support hexo-abbrlink</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/.*\/index\.html$/</span>.test(link)) &#123;</span><br><span class="line">      <span class="comment">// when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html</span></span><br><span class="line">      <span class="comment">// image in xxtitle/ will go to xxtitle/index/</span></span><br><span class="line">      appendLink = <span class="string">&#x27;index/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    link = link.substring(beginPos, endPos) + <span class="string">&#x27;/&#x27;</span> + appendLink;</span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;data-src&#x27;</span>))&#123;</span><br><span class="line">          <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">          <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;data-src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">          <span class="keyword">if</span>(!(<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src)</span><br><span class="line">            || <span class="regexp">/^\s+\//</span>.test(src)</span><br><span class="line">            || <span class="regexp">/^\s*\/uploads|images\//</span>.test(src))) &#123;</span><br><span class="line">            <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">            <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">            <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">            srcArray.shift();</span><br><span class="line">            src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            $(<span class="built_in">this</span>).attr(<span class="string">&#x27;data-src&#x27;</span>, config.root + link + src);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">          <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客建设</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>os.urandom()编码问题</title>
    <url>/2021/11/30/os-urandom-%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>用<code>os.urandom()</code>生成随机加密 key 的时候，出现了奇怪的结果，起初以为是编码问题，然后尝试对其解码，结果各种方式都不能正确解码</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; python <span class="literal">-c</span> <span class="string">&#x27;import os;print(os.urandom(16))&#x27;</span></span><br><span class="line">b<span class="string">&#x27;@\\\x96|\x862Brv!y\xa9\x9fr#-&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>网上查类似的文章，最终得到如下解决方案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">binascii.hexlify(os.urandom(<span class="number">16</span>))</span><br></pre></td></tr></table></figure>

<p>处理后得到正常的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;405c967c86324272762179a99f72232d&#x27;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>生成 16 位随机字节串的时候错误地对其进行了 hex 解码，导致出现奇怪的结果，因此需要得到正常的结果需要对其进行 hex 编码而不是解码。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>python tkinter事件</title>
    <url>/2021/12/15/python-tkinter%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>tkinter事件大概就这些内容，本文尚未完篇，有空更新，可以先参考这篇文章：<a href="https://pythonguides.com/python-tkinter-events/">https://pythonguides.com/python-tkinter-events/</a></p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>define</p>
<h1 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h1><p>bind() 方法的语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widget.bind(event,handler,add=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>example</p>
<span id="more"></span>

<h1 id="事件列表"><a href="#事件列表" class="headerlink" title="事件列表"></a>事件列表</h1><p>tkinter自带的事件：</p>
<ul>
<li><strong>Button</strong> – 点击按钮时触发Button事件，回调参数中event包含x,y属性返回点击时的坐标<ul>
<li><Button-1>：鼠标左击事件</Button-1></li>
<li><Button-2>：鼠标中击事件</Button-2></li>
<li><Button-3>：鼠标右击事件</Button-3></li>
<li><Double-Button-1>：双击事件</Double-Button-1></li>
<li><Triple-Button-1>：三击事件</Triple-Button-1></li>
<li><Bx-Motion>：鼠标移动事件,x=[1,2,3]分别表示左、中、右鼠标操作</Bx-Motion></li>
<li><ButtonRelease-x>鼠标释放事件,x=[1,2,3],分别表示鼠标的左、中、右键操作</ButtonRelease-x></li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>Configure</strong>– configure is used to change the property of a widget.</p>
</li>
<li><p><strong>Focus</strong>– completely focus on a particular widget.</p>
</li>
<li><p><strong>Destroy</strong>-Terminate the particular widget.</p>
</li>
<li><p><strong>Motion</strong>– Even where the mouse move entire on the widget.</p>
</li>
</ul>
<p>example</p>
<h1 id="事件小部件"><a href="#事件小部件" class="headerlink" title="事件小部件"></a>事件小部件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">event.widget</span><br></pre></td></tr></table></figure>

<p>example</p>
<h1 id="事件属性"><a href="#事件属性" class="headerlink" title="事件属性"></a>事件属性</h1><p>这里代码中使用的一些事件属性是：</p>
<ul>
<li><strong>.char</strong>定义字母表的正常字符。</li>
<li><strong>.height</strong>属性用于将小部件设置为新高度。</li>
<li><strong>.keysym</strong>属性用于设置字符串中的键、数字、特殊字符。</li>
</ul>
<h1 id="事件生成"><a href="#事件生成" class="headerlink" title="事件生成"></a>事件生成</h1><p>以下语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widget.event_generate(sequence,when=<span class="string">&#x27;tail&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>event_geterate</strong>使用<strong>when</strong>属性<strong>when=’tail’ 产生</strong>。<strong>tail</strong>是在处理完任何事件后将其附加到事件队列中。</p>
<p>example</p>
<h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap_Text</span>():</span></span><br><span class="line">    lab[<span class="string">&#x27;text&#x27;</span>] = time.asctime()</span><br><span class="line"></span><br><span class="line">    ws.after(<span class="number">1000</span>, swap_Text)</span><br></pre></td></tr></table></figure>



<h1 id="事件侦听"><a href="#事件侦听" class="headerlink" title="事件侦听"></a>事件侦听</h1><p>事件侦听器有两种使用方式：</p>
<ul>
<li>使用新消息调用侦听器。</li>
<li>通过调用 on_message_received 方法。</li>
</ul>
<p>在下面的代码中，我们通过设置预定义的值来创建一个小部件和一个事件侦听器，当我们在后台删除时，它会调用事件侦听器。</p>
<ul>
<li>**event_listener.set()**用于设置预定义值。</li>
<li>**event_listener.trace()**用于修改预定义值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">event_listener = StringVar()</span><br><span class="line">event_listener.set(&quot;DELETE ME&quot;)</span><br><span class="line">event_listener.trace(&quot;w&quot;, modify)</span><br><span class="line"></span><br><span class="line">entry_widget = Entry(ws, textvariable = event_listener)</span><br><span class="line">entry_widget.pack()</span><br><span class="line"></span><br><span class="line">ws.mainloop()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tkinter</tag>
        <tag>gui</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title>tkinter command传参问题解决</title>
    <url>/2021/12/11/tkinter-command%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>解决方案思路来自 <a href="https://stackoverflow.com/questions/6920302/how-to-pass-arguments-to-a-button-command-in-tkinter">https://stackoverflow.com/questions/6920302/how-to-pass-arguments-to-a-button-command-in-tkinter</a></p>
<p>其实使用的都是封装的方法，只是有不同的实现。</p>
<h2 id="方案一：lambda函数"><a href="#方案一：lambda函数" class="headerlink" title="方案一：lambda函数"></a>方案一：lambda函数</h2><p><strong>个人比较喜欢这个方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ttk.Button(frame, text=<span class="string">&#x27;button&#x27;</span>,command=<span class="keyword">lambda</span>:func(param))</span><br></pre></td></tr></table></figure>

<p>值得注意的是，这里存在一个小细节，不了解lambda函数机制的同学要注意一下，否则可能产生与你预期不符的结果。lambda函数只会在<strong>调用时</strong>执行内部语句，也就是说，如果你传递的参数（这里是param）是一个变量，并且在之后这个变量的值发生了变化，调用时就会传入之后的值而不是你之前想要传入的值。</p>
<span id="more"></span>

<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_add_one</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;这个函数对参数加一并打印&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(a+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">button = ttk.Button(frame, text=<span class="string">&quot;press&quot;</span>,command=<span class="keyword">lambda</span>:print_add_one(a))</span><br><span class="line">a = <span class="number">5</span></span><br><span class="line"><span class="comment"># 点击这个按钮输出会是 6</span></span><br></pre></td></tr></table></figure>

<p>如果你正好有动态传值的需要，那么这个恰能符合你的需求。如果你想要传入固定的参数值，则我们需要用到默认参数解决这一问题。</p>
<p>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> p=param:func(p)</span><br></pre></td></tr></table></figure>

<p>这样就能把参数固定下来了。</p>
<h2 id="方案二：类封装"><a href="#方案二：类封装" class="headerlink" title="方案二：类封装"></a>方案二：类封装</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callback</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func, *args, **kwargs</span>):</span></span><br><span class="line">        self.func = func</span><br><span class="line">        self.args = args</span><br><span class="line">        self.kwargs = kwargs</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.func(*self.args, **self.kwargs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default_callback</span>(<span class="params">t</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Button &#x27;&#123;&#125;&#x27; pressed.&quot;</span>.<span class="built_in">format</span>(t))</span><br><span class="line"></span><br><span class="line">root = tk.Tk()</span><br><span class="line"></span><br><span class="line">buttons = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, b <span class="keyword">in</span> <span class="built_in">enumerate</span>(buttons):</span><br><span class="line">    tk.Button(root, text=b, command=Callback(default_callback, b)).grid(row=i, column=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">tk.mainloop()</span><br></pre></td></tr></table></figure>

<p>这里不多做介绍了，调用的地方像这样实例化一个对象就行了。</p>
<h2 id="方案三：functools的partial"><a href="#方案三：functools的partial" class="headerlink" title="方案三：functools的partial"></a>方案三：functools的partial</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line">button = Tk.Button(master=frame, text=<span class="string">&#x27;press&#x27;</span>, command=partial(func, arg))</span><br></pre></td></tr></table></figure>

<p>partial用于创建一个类似原函数但有固定参数的偏函数，原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">functools.partial(func, *args, **keywords)</span><br></pre></td></tr></table></figure>

<p>和方案二玩法差不多，具体不多介绍了。</p>
<blockquote>
<p>Note:</p>
<p>有趣的是，python类绑定方法的实现与partial有异曲同工之妙，感兴趣的同学可以了解一下</p>
</blockquote>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title>tkinter手动代理窗口关闭事件</title>
    <url>/2021/12/15/tkinter%E6%89%8B%E5%8A%A8%E4%BB%A3%E7%90%86%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>有时想在关闭窗口时做一些额外的处理，比如：保存数据、弹出确认对话框等。</p>
<p>这时就需要代理窗口关闭事件，下面的代码展示了如何代理窗口关闭事件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close_handler</span>():</span></span><br><span class="line">    beforeCloseOpr()</span><br><span class="line">    root.destory()</span><br><span class="line"></span><br><span class="line">root.protocol(<span class="string">&quot;WM_DELETE_WINDOW&quot;</span>, close_handler)</span><br></pre></td></tr></table></figure>

<p>在关闭窗口事件触发时，调用 close_handler 函数代为处理，这里会先执行 beforeCloseOpr() 函数，然后再关闭窗口。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tkinter</tag>
        <tag>gui</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title>turtle字体粗糙定位</title>
    <url>/2021/12/16/turtle%E5%AD%97%E4%BD%93%E7%B2%97%E7%B3%99%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<p>不同的字体<strong>实现</strong>不同，有<strong>等宽</strong>和<strong>非等宽</strong>，非等宽字体<strong>不同字符宽度不同</strong>，<strong>宽高比</strong>也各不相同，而且<strong>字体尺寸</strong>和<strong>像素</strong>是无法直接转换的。因此，今天介绍的方法<strong>并非完美的解决方案</strong>，只是用于<strong>粗糙估算turtle中字符的长宽</strong>，用于在字符上绘图进行绘图操作，如<strong>圈画文本</strong>等。</p>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h2><p>turtle中用于书写文本的函数为write</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">turtle.write(arg, move=<span class="literal">False</span>, align=<span class="string">&quot;left&quot;</span>, font=(<span class="string">&quot;Arial&quot;</span>, <span class="number">8</span>, <span class="string">&quot;normal&quot;</span>))</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><p><strong>arg</strong> – 要书写到 TurtleScreen 的对象<br>如：”something”，123，(1,2)，[1,2,3]等</p>
</li>
<li><p><strong>move</strong> – True/False<br>如果 move 为 True，画笔会移动到文本的右下角，这样文字就不会叠在一块了。</p>
</li>
<li><p><strong>align</strong> – 字符串 “left”, “center” 或 “right”<br>align 指定对齐方式 (“left”, “center” 或 right”)</p>
</li>
<li><p><strong>font</strong> – 一个三元组 (fontname, fontsize, fonttype)<br>font 指定字体</p>
</li>
</ul>
<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>书写文本 arg 指定的字符串到当前海龟位置。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这里有两种思路，都不精确，第一种直接估算，第二种根据宽度估算，各有优劣，仅供参考：</p>
<ol>
<li><p>用<strong>fontsize近似代替宽度</strong>，然后用<strong>估测的纵横比</strong>近似估算高度，得到字符长宽参数，进而确定位置。</p>
</li>
<li><p>由于每个字宽度不同，所以可以单独绘制每个字符，将move设为True，这样在写每个字符时，画笔会跟着移动，可以<strong>记录其始末位置</strong>，作差得到<strong>每个字符的宽度</strong>。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>这里我们实现了在turtle中对文本部分子串进行圈画的功能，其中两种思路都有涉及。</p>
<p>最后选用记录的宽度作为画圈的直径。另外，因为每个字符高度差不多，所以高度统一采用估算的高度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"></span><br><span class="line">turtle.speed(<span class="number">0</span>)</span><br><span class="line">turtle.delay(<span class="number">0</span>)</span><br><span class="line">turtle.hideturtle()</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;ACTACGTCAGCTCGTCATCGGTACGTCTCVATGACGTCGT&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选取字符串子串位置，闭区间[start_idx, end_idx]</span></span><br><span class="line">start_idx = <span class="number">33</span></span><br><span class="line">end_idx = <span class="number">36</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pos用于存储对应位置字符的始末x坐标</span></span><br><span class="line">pos = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字体设置</span></span><br><span class="line">font_setting = (<span class="string">&quot;Arial&quot;</span>, <span class="number">16</span>, <span class="string">&quot;normal&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同字体实现不同，且不同字符长宽又不同</span></span><br><span class="line"><span class="comment"># 这里假设字符像素宽度近似fontsize，宽高比为1.5倍</span></span><br><span class="line"><span class="comment"># 如果想更精确，请自己根据特定字体精调参数</span></span><br><span class="line">aspect_ratio = <span class="number">1.5</span></span><br><span class="line">font_width = font_setting[<span class="number">1</span>]</span><br><span class="line">font_height = font_width*aspect_ratio</span><br><span class="line"></span><br><span class="line">turtle.penup()</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> text:</span><br><span class="line">    <span class="comment"># 单独绘制每个字符</span></span><br><span class="line">    start = turtle.position()[<span class="number">0</span>]</span><br><span class="line">    turtle.write(ch, move=<span class="literal">True</span>, font=font_setting)</span><br><span class="line">    end = turtle.position()[<span class="number">0</span>]</span><br><span class="line">    pos.append((start, end))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算直径半径</span></span><br><span class="line">d = pos[end_idx][<span class="number">1</span>] - pos[start_idx][<span class="number">0</span>]</span><br><span class="line">r = d/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算circle函数绘制起点坐标</span></span><br><span class="line">center_x = (pos[end_idx][<span class="number">1</span>] + pos[start_idx][<span class="number">0</span>])/<span class="number">2</span></span><br><span class="line">center_y = font_height/<span class="number">2</span> - r + <span class="number">1.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置画笔</span></span><br><span class="line">turtle.pencolor(<span class="string">&quot;red&quot;</span>)</span><br><span class="line">turtle.pensize(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">turtle.setposition(center_x, center_y)</span><br><span class="line">turtle.pendown()</span><br><span class="line">turtle.circle(r)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;Press Enter to continue...&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img data-src="/2021/12/16/turtle%E5%AD%97%E4%BD%93%E7%B2%97%E7%B3%99%E5%AE%9A%E4%BD%8D/image-20211216233550935.png" alt="demo-1"></p>
<p><img data-src="/2021/12/16/turtle%E5%AD%97%E4%BD%93%E7%B2%97%E7%B3%99%E5%AE%9A%E4%BD%8D/image-20211216233747578.png" alt="image-20211216233747578"></p>
<blockquote>
<p>Note</p>
<p>这里仅用于演示，因此圈画功能简单使用了circle函数，绘制的是圆形，在圈画较长或较短字符串时并不美观，实际使用时可以根据需求自己调整，比如绘制椭圆或方框等其他圈画方式。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>turtle</tag>
      </tags>
  </entry>
  <entry>
    <title>turtle绘图速度</title>
    <url>/2021/12/16/turtle%E7%BB%98%E5%9B%BE%E9%80%9F%E5%BA%A6/</url>
    <content><![CDATA[<ul>
<li>最快的画笔移动速度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">turtle.speed(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>最快的画笔移动速度+取消绘画过程的延迟</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">turtle.speed(<span class="number">0</span>)</span><br><span class="line">turtle.delay(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>跳过绘制过程（直接成像）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">turtle.tracer(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h1><h2 id="speed"><a href="#speed" class="headerlink" title="speed"></a>speed</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">turtle.speed(speed=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><p>speed：一个 0到10 范围内的整型数或速度字符串（如果输入数值大于 10 或小于 0.5 则速度设为 0）</p>
</li>
<li><p>不传入参数：返回当前海龟的速度</p>
<p>speed关键字对应表：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字符串</th>
<th align="center">数字</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">“fastest”</td>
<td align="center">0</td>
<td align="center">最快</td>
</tr>
<tr>
<td align="center">“fast”</td>
<td align="center">10</td>
<td align="center">快</td>
</tr>
<tr>
<td align="center">“normal”</td>
<td align="center">6</td>
<td align="center">正常</td>
</tr>
<tr>
<td align="center">“slow”</td>
<td align="center">3</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">“slowest”</td>
<td align="center">1</td>
<td align="center">最慢</td>
</tr>
</tbody></table>
<p>速度值从 1 到 10，画线和海龟转向的动画效果逐级加快。speed = 0 表示没有动画效果（转向），但绘制还是需要时间，最快。</p>
<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>设置海龟移动的速度或返回当前海龟的速度。</p>
<h2 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">turtle.delay(delay=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<h3 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h3><ul>
<li>delay：正整型数</li>
<li>不传参：返回以毫秒数表示的延迟值 delay</li>
</ul>
<h3 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h3><p>设置或返回以毫秒数表示的延迟值 delay（约等于连续两次画布刷新的间隔时间）。 绘图延迟越长，动画速度越慢。</p>
<h2 id="tracer"><a href="#tracer" class="headerlink" title="tracer"></a>tracer</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">turtle.tracer(n=<span class="literal">None</span>, delay=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<h3 id="参数：-2"><a href="#参数：-2" class="headerlink" title="参数："></a>参数：</h3><ul>
<li>n：非负整型数（0/False 表示不启用动画）</li>
<li>delay：非负整型数（等同于上文delay函数）</li>
<li>不传参：返回当前的 n 值</li>
</ul>
<h3 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a>作用：</h3><p>启用/禁用海龟动画并设置刷新图形的延迟时间。</p>
<p>文末推荐一篇详细的学习 turtle 的文章：<a href="https://blog.csdn.net/sandalphon4869/article/details/99443949">https://blog.csdn.net/sandalphon4869/article/details/99443949</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>turtle</tag>
      </tags>
  </entry>
  <entry>
    <title>终端中手动输入EOF</title>
    <url>/2022/03/14/%E7%BB%88%E7%AB%AF%E4%B8%AD%E6%89%8B%E5%8A%A8%E8%BE%93%E5%85%A5EOF/</url>
    <content><![CDATA[<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><ul>
<li>windows 10</li>
<li>ubtuntu 20.04</li>
</ul>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>新起一行输入<code>Ctrl-Z</code>，然后回车</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p>新起一行输入<code>Ctrl-D</code></p>
<h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><p>同一行中，连续输入两次<code>Ctrl-D</code></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>EOF</tag>
        <tag>终端</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>键冲突报错注入详解</title>
    <url>/2021/12/14/%E9%94%AE%E5%86%B2%E7%AA%81%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>利用<code>RAND()</code>和<code>GROUP BY</code>，以包含<code>RAND()</code>的数据为键进行分组（GROUP BY），在执行过程中，<code>GROUP BY</code>会读取每一行数据，如果已存在相应的键值会更新对应行的值，否则会插入该键值，而插入该键值时会重新执行<code>RAND()</code>函数，而不是用之前读取到的值，如果此时<code>RAND()</code>生成了与已有键值冲突的值，则会导致主键冲突报错，报错格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;&lt;group&gt;&#x27; for key &#x27;&lt;group_key&gt;&#x27;</span><br></pre></td></tr></table></figure>

<p>其中<code>&lt;group&gt;</code>是前面<code>GROUP BY</code>分组所用的键值。</p>
<span id="more"></span>

<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>为了方便观察，我调整了SQL注入语句的格式，其中注释包含的内容是查询语句，要求只能查询返回单个结果的语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">AND</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">        <span class="built_in">COUNT</span>(<span class="operator">*</span>),</span><br><span class="line">        CONCAT</span><br><span class="line">        (</span><br><span class="line">            <span class="built_in">FLOOR</span>(RAND(<span class="number">0</span>)<span class="operator">*</span><span class="number">2</span>),</span><br><span class="line">            (</span><br><span class="line">                <span class="comment">-- query begin --</span></span><br><span class="line">                <span class="keyword">SELECT</span></span><br><span class="line">                CONCAT</span><br><span class="line">                (</span><br><span class="line">                    <span class="number">0x7e7e3a7e7e</span>,</span><br><span class="line">                    <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> table_schema),</span><br><span class="line">                    <span class="number">0x7e7e3a7e7e</span></span><br><span class="line">                )</span><br><span class="line">                <span class="keyword">FROM</span></span><br><span class="line">                information_schema.tables</span><br><span class="line">            	LIMIT <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        		<span class="comment">-- query end --</span></span><br><span class="line">            )</span><br><span class="line">        ) x</span><br><span class="line">        <span class="keyword">FROM</span> information_schema.tables</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> x</span><br><span class="line">    ) a</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>整理压缩后：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>),CONCAT(<span class="built_in">FLOOR</span>(RAND(<span class="number">0</span>)<span class="operator">*</span><span class="number">2</span>),(<span class="keyword">SELECT</span> CONCAT(<span class="number">0x7e7e3a7e7e</span>,<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> table_schema),<span class="number">0x7e7e3a7e7e</span>) <span class="keyword">FROM</span> information_schema.tables LIMIT <span class="number">0</span>,<span class="number">1</span>)) x <span class="keyword">FROM</span> information_schema.tables <span class="keyword">GROUP</span> <span class="keyword">BY</span> x) a)</span><br></pre></td></tr></table></figure>
<h2 id="关键语句"><a href="#关键语句" class="headerlink" title="关键语句"></a>关键语句</h2><ul>
<li>RAND()</li>
<li>FLOOR()</li>
<li>COUNT()</li>
<li>GROUP BY</li>
</ul>
<h3 id="RAND"><a href="#RAND" class="headerlink" title="RAND()"></a>RAND()</h3><p>产生一个 0<del>1 的伪随机数，加上固定随机数种子后返回的数值序列会固定。<code>RAND(0)*2</code>可以生成 0</del>2 之间的固定值序列。在公式中用于结合其他函数生成 0,1 的固定序列使键值重复。</p>
<p><img data-src="/2021/12/14/%E9%94%AE%E5%86%B2%E7%AA%81%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/image-20211114001752437.png" alt="RAND(0)*2"></p>
<h3 id="FLOOR"><a href="#FLOOR" class="headerlink" title="FLOOR()"></a>FLOOR()</h3><p>向下取整。<code>FLOOR(RAND(0)*2)</code>可以生成固定的 0,1 值序列。</p>
<p><img data-src="/2021/12/14/%E9%94%AE%E5%86%B2%E7%AA%81%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/image-20211114001725708.png" alt="FLOOR(RAND(0)*2)"></p>
<h3 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT()"></a>COUNT()</h3><p>返回匹配指定条件的行数。<code>COUNT()</code>即为一种简单的聚合函数，可以配合<code>GROUP BY</code>实现分组并聚合数据。</p>
<blockquote>
<p>这里不一定要使用<code>COUNT()</code>，也可以使用其他聚合函数。</p>
<p>关于聚合函数的更多知识，这里不作赘述，感兴趣的可以自行搜索。</p>
</blockquote>
<h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><p>用于结合聚合函数，根据一个或多个列对结果集进行分组。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> key_name, aggregate_function(column_name)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name operator <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> key_name;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>aggregate_function()</code>表示一种聚合函数</p>
</blockquote>
<p>工作过程：</p>
<div id="flowchart-0" class="flow-chart"></div>

<p>关注到工作流程图中的两个子程序，分别在两次取数据时执行了数据中的子语句，这是该类报错注入的核心，因为两次分别执行了数据中的子语句，导致判断时用的键值和插入时的键值可能不同，从而可能插入已存在的键值，导致主键冲突。</p>
<h2 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h2><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>在一个SELECT语句里还有一个SELECT语句，里面的这个SELECT语句就是子查询。执行的时候，会先执行子查询。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT concat((SELECT database()));</span><br></pre></td></tr></table></figure>

<p>先执行<code>SELECT database()</code>这个语句就会把当前的数据库查出来，然后把结果传入到concat函数，然后再执行外面的查询。</p>
<h3 id="报错原理"><a href="#报错原理" class="headerlink" title="报错原理"></a>报错原理</h3><p>把造成报错的核心语句取出：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>),<span class="built_in">FLOOR</span>(RAND(<span class="number">0</span>)<span class="operator">*</span><span class="number">2</span>) x <span class="keyword">FROM</span> information_schema.tables <span class="keyword">GROUP</span> <span class="keyword">BY</span> x</span><br></pre></td></tr></table></figure>

<p><code>FLOOR(RAND(0)*2)</code>返回的序列上文已提及</p>
<p><img data-src="/2021/12/14/%E9%94%AE%E5%86%B2%E7%AA%81%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/image-20211114001725708-16394634484961.png" alt="FLOOR(RAND(0)*2)"></p>
<p>这里我们一步步分析</p>
<blockquote>
<p>待会依次调用<code>FLOOR(RAND(0)*2)</code>，会按顺序返回 [0,1,1,0,1]，请记住这个序列。</p>
</blockquote>
<h4 id="1-GROUP-BY创建了一个临时表"><a href="#1-GROUP-BY创建了一个临时表" class="headerlink" title="1. GROUP BY创建了一个临时表"></a>1. <code>GROUP BY</code>创建了一个临时表</h4><p><code>x</code>是<code>FLOOR(RAND(0)*2)</code>的别名</p>
<table>
<thead>
<tr>
<th>x</th>
<th>COUNT(*)</th>
</tr>
</thead>
</table>
<h4 id="2-读取了第一行数据"><a href="#2-读取了第一行数据" class="headerlink" title="2. 读取了第一行数据"></a>2. 读取了第一行数据</h4><p>操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>取出第一条数据</td>
<td>得到 x, COUNT(*) = 0, 1</td>
</tr>
<tr>
<td>判断临时表是否存在对应键</td>
<td>没有</td>
</tr>
<tr>
<td>向临时表插入键值</td>
<td>插入 x, COUNT(*) = 1, 1</td>
</tr>
</tbody></table>
<p>临时表</p>
<table>
<thead>
<tr>
<th>x</th>
<th>COUNT(*)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<h4 id="3-读取第二行数据"><a href="#3-读取第二行数据" class="headerlink" title="3. 读取第二行数据"></a>3. 读取第二行数据</h4><p>操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>取出第二条数据</td>
<td>得到 x, COUNT(*) = 1, 1</td>
</tr>
<tr>
<td>判断临时表是否存在对应键</td>
<td>存在</td>
</tr>
<tr>
<td>向临时表更新键值</td>
<td>x=1, COUNT(*)+1</td>
</tr>
</tbody></table>
<p>临时表</p>
<table>
<thead>
<tr>
<th>x</th>
<th>COUNT(*)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
</tr>
</tbody></table>
<h4 id="4-读取第三行数据"><a href="#4-读取第三行数据" class="headerlink" title="4. 读取第三行数据"></a>4. 读取第三行数据</h4><p>操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>取出第三条数据</td>
<td>得到 x, COUNT(*) = 0, 1</td>
</tr>
<tr>
<td>判断临时表是否存在对应键</td>
<td>没有</td>
</tr>
<tr>
<td>向临时表插入键值</td>
<td>插入 x, COUNT(*) = 1, 1  =&gt; 主键冲突报错</td>
</tr>
</tbody></table>
<p>因为插入时重新生成了另一个 x 值，而此时的 x 为已存在的键，插入造成了主键冲突，产生了报错</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ul>
<li>sqli-labs less-5</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主键冲突报错注入的原理至此已经阐明。为了不造成读者疑惑，本文中的注入公式采用的是网上流行的版本加以精简，随机数种子也沿用了传统的 0 ，该种子要求<strong>所查表中至少要存在三条记录</strong>才能报错。</p>
<p>实际上，可以更优化该公式实现<strong>两条以上记录就完成报错</strong>。具体实现只要找到随机数种子使公式产生 [0,1,0,1] 或 [1,0,1,0] 的序列即可，这里笔者找到<strong>随机数种子为 14</strong> 时，可以产生 [1,0,1,0] 的序列。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.freebuf.com/column/235496.html">Mysql报错注入之floor(rand(0)*2)报错原理探究</a></li>
<li><a href="https://www.jianshu.com/p/8c2343705100">【转载】SQL注入之报错型注入</a></li>
<li><a href="https://blog.csdn.net/Leep0rt/article/details/78556440">【转载】详细讲解双查询注入</a></li>
<li><a href="https://www.w3school.com.cn/sql/sql_func_count.asp">SQL COUNT() 函数</a></li>
</ol>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始
create_tmp_table=>operation: 创建用于存储分组结果的表，并将 key_name 设为主键
read_key_value=>operation: 读取数据集中的一条记录
execute_sub_query=>subroutine: 同时执行数据中的语句
select_data=>operation: 取出所需数据
isExist=>condition: 判断临时表中是否已存在该键值
update_data=>operation: 更新临时表中对应的分组数据
insert_key=>operation: 向临时表插入新组数据
execute_sub_query_again=>subroutine: 重新执行数据中的语句
isReadAll=>condition: 是否读取完毕
ed=>end: 结束

st->create_tmp_table->read_key_value->select_data->execute_sub_query->isExist
isExist(yes)->update_data->isReadAll
isExist(no)->execute_sub_query_again->insert_key->isReadAll
isReadAll(yes)->ed
isReadAll(no)->read_key_value</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>ctf</tag>
        <tag>web</tag>
        <tag>sqli</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中const关键字的修饰对象</title>
    <url>/2022/03/15/C%E8%AF%AD%E8%A8%80%E4%B8%ADconst%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BF%AE%E9%A5%B0%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="一般（非指针）变量"><a href="#一般（非指针）变量" class="headerlink" title="一般（非指针）变量"></a>一般（非指针）变量</h2><p>对于一般类型（指非指针）变量，<code>const</code>关键字表明该变量为常量，其值不能被修改，声明一个常量和声明一个变量的方法类似：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br></pre></td></tr></table></figure>

<p>这两种方法等价。</p>
<h2 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h2><p>对于指针变量，<code>const</code>可能修饰的对象就有指针和指针指向的实体两种了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *pic;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> cpi;</span><br></pre></td></tr></table></figure>

<p>第一种和第二种修饰的是指针指向的实体，第三种则修饰指针。</p>
<p>简单小结一下，就是如果<code>const</code>在<code>*</code>（解引用/间接）运算符前，修饰的就是实体；在<code>*</code>后则修饰指针。</p>
<h2 id="多个变量"><a href="#多个变量" class="headerlink" title="多个变量"></a>多个变量</h2><p>考虑更复杂的情况，当同时存在多个变量时，<code>const</code>对后续变量是否有效？</p>
<p>利用下述测试代码，通过对<code>const</code>限定符的变量进行修改，可以得到编译器的错误信息，从而得知<code>const</code>的作用范围：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">1</span>, b=<span class="number">2</span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> c=<span class="number">3</span>, d=<span class="number">4</span>;</span><br><span class="line">    c = d;</span><br><span class="line">    d = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> e=<span class="number">5</span>,f=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> *<span class="keyword">const</span> pe=&amp;e, *pf=&amp;f;</span><br><span class="line">    pe = pf;</span><br><span class="line">    pf = pe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *pe2=&amp;e, *pf2=&amp;f;</span><br><span class="line">    *pe2 = f;</span><br><span class="line">    *pf2 = e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/03/15/C%E8%AF%AD%E8%A8%80%E4%B8%ADconst%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BF%AE%E9%A5%B0%E5%AF%B9%E8%B1%A1/image-20220315131946929.png" alt="result"></p>
<p>可见，只有单独对指针进行修饰的<code>const</code>关键字是只作用于单个变量的，其余都是对后续声明生效的。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>const</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言链接属性</title>
    <url>/2022/03/17/C%E8%AF%AD%E8%A8%80%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="什么是链接属性"><a href="#什么是链接属性" class="headerlink" title="什么是链接属性"></a>什么是链接属性</h1><p>链接属性与C语言中各个目标文件及函数的链接过程有关，用于认定不同文件的标识符（程序中的各种名称，包括变量名、函数名）是否是同一个实体。更通俗地说，就是在两个不同文件中的变量、函数声明是否指向同一个实体。比如：a、b文件同时声明了变量c，链接属性就指定了这两处变量c是否是同一个c。</p>
<p>简单来说，链接属性的作用就是让你能在a文件中决定要不要访问b文件中的变量、函数。</p>
<h1 id="链接属性的分类"><a href="#链接属性的分类" class="headerlink" title="链接属性的分类"></a>链接属性的分类</h1><p>链接属性有三种：</p>
<ul>
<li>external - 外部链接</li>
<li>internal - 内部链接</li>
<li>none - 无链接</li>
</ul>
<p>对于external属性的标识符，不同文件中出现的多个同名称标识符指向同一个实体。在C语言中，用extern关键字在声明中指定<strong>以引用其他文件中定义的相同标识符</strong>。</p>
<p>对于internal属性的标识符，仅在当前文件内该标识符指向同一个实体。在C语言中，用static关键字在声明中指定让标识符<strong>变为该文件私有</strong>（只有对<strong>原本缺省的链接属性为external</strong>的标识符，才能用static关键字改变其链接属性为internal）。</p>
<p>对于none属性的标识符，在每个声明位置都是一个新的实体。C语言中，没有对应的关键字。</p>
<h1 id="默认的链接属性"><a href="#默认的链接属性" class="headerlink" title="默认的链接属性"></a>默认的链接属性</h1><p>标识符的默认的链接属性与其出现的位置有关。</p>
<ul>
<li><p>程序的全局变量、所有函数默认的链接属性为external。</p>
</li>
<li><p>其余标识符的默认链接属性为none。</p>
</li>
</ul>
<p>在以下例子中，b、c、f的链接属性就是external：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> g)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实践应用"><a href="#实践应用" class="headerlink" title="实践应用"></a>实践应用</h1><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>在a文件中想要使用b文件中定义的external属性标识符，可使用extern关键字在a文件中声明。</p>
<blockquote>
<p><strong>即使该标识符所在位置默认链接属性为external</strong>，也建议使用extern关键字显式说明，有利于增加程序可读性。</p>
</blockquote>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>在a文件定义了一个全局标识符，但不想被其他文件访问，可以对该标识符加上static关键字。</p>
<p>在a、b文件中定义了同样的标识符，通过static关键字可以避免多重定义问题。</p>
<blockquote>
<p>再次提醒：只有对<strong>原本缺省的链接属性为external</strong>的标识符，才能用static关键字改变其链接属性为internal</p>
</blockquote>
<h1 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h1><ol>
<li>对于external属性的标识符，你可以在多个不同源文件中声明，但是你只能在一处初始化。否则就会出现重复定义的问题：<code>multiple definition of &#39;a&#39;;</code>。</li>
<li>extern关键字声明的标识符用于访问其他文件中定义的同名的标识符，因此无法进行初始化。如果你对extern声明的变量进行初始化就会生成警告：<code>warning: ‘a’ initialized and declared ‘extern’</code>。</li>
<li>如果在其他文件中不存在相应的标识符定义，却在当前文件中使用了extern声明，会报错：<code>undefined reference to &#39;a&#39;</code>，原理同2。</li>
<li>external属性的标识符总是静态存储类型。</li>
<li>static关键字还有改变存储类型的作用，因此，其作用与上下文环境有关，只有对于默认链接属性为external的标识符，才有改变链接属性的作用。</li>
<li>C++中，const变量隐含的具有internal属性，C中并不具有这一性质。</li>
</ol>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="internal和none属性除了作用域不同还有什么区别？"><a href="#internal和none属性除了作用域不同还有什么区别？" class="headerlink" title="internal和none属性除了作用域不同还有什么区别？"></a>internal和none属性除了作用域不同还有什么区别？</h2><p>以下代码一定程度上阐释了部分区别：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i; <span class="comment">// definition</span></span><br><span class="line">              <span class="comment">// static storage</span></span><br><span class="line">              <span class="comment">// internal linkage</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// declaration</span></span><br><span class="line">                  <span class="comment">// refers to the static i at file scope</span></span><br><span class="line">                  <span class="comment">// note that even though the specifier is extern</span></span><br><span class="line">                  <span class="comment">// its linkage is intern (this is legal in both C/C++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i; <span class="comment">// definition</span></span><br><span class="line">               <span class="comment">// automatic storage</span></span><br><span class="line">               <span class="comment">// no linkage</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上链接属性和作用域是两个概念。之所以产生以上问题，因为internal属性标识符出现的位置都是在文件作用域，而none往往在代码块作用域。此处想引起读者对内链接更深入的思考，见问题2。</p>
</blockquote>
<h2 id="文件作用域已经能让程序访问同一文件变量，那么再进行内部链接的意义在哪"><a href="#文件作用域已经能让程序访问同一文件变量，那么再进行内部链接的意义在哪" class="headerlink" title="文件作用域已经能让程序访问同一文件变量，那么再进行内部链接的意义在哪?"></a>文件作用域已经能让程序访问同一文件变量，那么再进行内部链接的意义在哪?</h2><p>同一个标识符在链接中只能存在一个，那么通过内部链接的方式可以隔绝同名外部链接，且限定了外部编译单元不能访问该文件全局标识符。</p>
<p>a.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b.c:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>编译后结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=3</span><br></pre></td></tr></table></figure>



<blockquote>
<p>以上仅为不完善的个人猜想，抛开隔绝外部链接这一点不谈，就内部链接这一名称而言，笔者对<strong>为什么要在同一个文件内部使用链接</strong>的设计仍然存疑，但目前该话题的答案超出了笔者的理解，因此更深入的讨论暂时留白。</p>
<p><strong>拓展</strong>：感兴趣的同学可以尝试学习<strong>链接</strong>相关知识，或许会找到答案。</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p>《Pointers On C》</p>
</li>
<li><p><a href="https://stackoverflow.com/questions/24864840/difference-between-internal-and-no-linkage">Difference between internal and no linkage</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>链接属性</tag>
      </tags>
  </entry>
</search>
